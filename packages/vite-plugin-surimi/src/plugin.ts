import path from 'node:path';
import { createFilter } from '@rollup/pluginutils';
import compile from '@surimi/compiler';
import type { PluginContext } from 'rollup';
import type { Plugin, ResolvedConfig, ViteDevServer } from 'vite';
import { normalizePath } from 'vite';

import type { SurimiOptions } from './types.js';

/**
 * Main plugin function that selects between build and dev modes
 */
export default function surimiPlugin(options: SurimiOptions = {}): Plugin[] {
  const { include = ['**/*.css.{ts,js}'], exclude = ['node_modules/**', '**/*.d.ts'], inlineCss = false } = options;
  const filter = createFilter(include, exclude);

  let resolvedConfig: ResolvedConfig | undefined;
  let isBuild: boolean | undefined;
  let server: ViteDevServer | undefined;

  // Build cache for production builds
  const buildCache = new Map<string, { css: string; js: string; cssFileId?: string }>();

  // Dependency mapping: dependency file -> Set of CSS files that depend on it
  const dependencyMap = new Map<string, Set<string>>();

  // Helper function to invalidate modules for HMR
  function invalidateModule(absoluteId: string) {
    if (!server) return;

    const { moduleGraph } = server;
    const modules = moduleGraph.getModulesByFile(absoluteId);

    if (modules) {
      for (const module of modules) {
        moduleGraph.invalidateModule(module);
        // Set timestamp for HMR
        module.lastHMRTimestamp = module.lastInvalidationTimestamp || Date.now();
      }
    }
  }

  // Helper function to register dependency relationships and watch files for HMR
  function registerDependencies(cssFile: string, watchFiles: string[], context: PluginContext) {
    for (const file of watchFiles) {
      if (
        typeof file === 'string' &&
        !file.includes('node_modules') &&
        !file.startsWith('rolldown:') &&
        normalizePath(file) !== normalizePath(cssFile)
      ) {
        context.addWatchFile(file);

        const normalizedFile = normalizePath(file);
        if (!dependencyMap.has(normalizedFile)) {
          dependencyMap.set(normalizedFile, new Set());
        }
        const dependencySet = dependencyMap.get(normalizedFile);
        if (dependencySet) {
          dependencySet.add(normalizePath(cssFile));
        }
      }
    }
  }

  return [
    {
      name: 'vite-plugin-surimi',
      config() {
        return {
          build: {
            rollupOptions: {
              external: ['rolldown:runtime', 'surimi'],
            },
          },
        };
      },
      configResolved(config) {
        resolvedConfig = config;
        isBuild = config.command === 'build' && !config.build.watch;
      },
      configureServer(_server) {
        server = _server;
      },
      handleHotUpdate(ctx) {
        if (!server || isBuild) return;

        const { file } = ctx;
        const normalizedFile = normalizePath(file);

        // Check if this file has dependents (CSS files that import it)
        const dependentCssFiles = dependencyMap.get(normalizedFile);

        if (dependentCssFiles && dependentCssFiles.size > 0) {
          console.log(`Dependency changed: ${file}`);
          console.log(`Invalidating dependent CSS files:`, Array.from(dependentCssFiles));

          // Invalidate all dependent CSS files
          for (const cssFile of dependentCssFiles) {
            invalidateModule(cssFile);
          }

          // Let Vite handle the standard HMR for the changed file itself
          return ctx.modules;
        }

        // If this is a CSS file itself, let it update normally
        if (filter(normalizedFile)) {
          return ctx.modules;
        }

        // For other files, use default HMR behavior
        return ctx.modules;
      },
    },
    {
      name: 'vite-plugin-surimi:dev',
      async transform(code, id) {
        if (isBuild) return null;

        if (filter(id)) {
          console.log('Processing Surimi file (dev mode):', id);

          try {
            // Compile the CSS-in-JS file
            const { css, watchFiles } = await compile({
              inputPath: normalizePath(id),
              cwd: resolvedConfig?.root ?? process.cwd(),
              include,
              exclude,
            });

            console.log('Compiled CSS (dev mode):', css);
            console.log('Watch files:', watchFiles);

            // Register dependencies for HMR tracking
            if (Array.isArray(watchFiles)) {
              registerDependencies(id, watchFiles, this);
            }

            // Return JavaScript that injects the CSS directly
            const jsCode = `${code}\n\n
// Auto-generated by vite-plugin-surimi (dev mode)
// Inject CSS directly into the page
const css = ${JSON.stringify(css)};
const styleId = 'surimi-style-' + ${JSON.stringify(id.replace(/[^a-zA-Z0-9]/g, '_'))};

// Remove existing style if it exists (for HMR)
const existingStyle = document.getElementById(styleId);
if (existingStyle) {
  existingStyle.remove();
}

// Create and inject new style element
const styleElement = document.createElement('style');
styleElement.id = styleId;
styleElement.textContent = css;
document.head.appendChild(styleElement);

// Hot Module Replacement support
if (import.meta.hot) {
  import.meta.hot.accept(() => {
    // The new version will be loaded automatically
  });
  
  import.meta.hot.dispose(() => {
    // Clean up when module is disposed
    const style = document.getElementById(styleId);
    if (style) {
      style.remove();
    }
  });
}
`;

            return jsCode;
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            this.error(`Failed to compile Surimi file ${id}: ${message}`);
          }
        }

        return null;
      },
    },
    {
      name: 'vite-plugin-surimi:build',
      async transform(code, id) {
        if (!isBuild) return null;

        if (filter(id)) {
          console.log('Processing Surimi file (build mode):', id);

          try {
            // Check if file was already compiled (caching)
            const cached = buildCache.get(id);
            let css: string;
            let source: string;
            let cssFileName = '';
            let cssFileId: string | undefined;

            if (cached) {
              console.log('Using cached compilation for:', id);
              css = cached.css;
              source = cached.js;
              cssFileId = cached.cssFileId;

              // Reconstruct filename from cached data if not inlining
              if (!inlineCss) {
                const parsedPath = path.parse(id);
                const baseName = parsedPath.name.replace(/\.css$/, '');
                cssFileName = `${baseName}.css`;
              }
            } else {
              console.log('Compiling Surimi file:', id);

              // Compile the CSS-in-JS file
              const result = await compile({
                inputPath: normalizePath(id),
                cwd: resolvedConfig?.root ?? process.cwd(),
                include,
                exclude,
              });

              css = result.css;
              source = result.js; // Use the transformed JS from compiler
              console.log('Compiled CSS:', css);
              console.log('Compiled JS:', result.js);

              if (inlineCss) {
                // Store in cache without emitting asset
                buildCache.set(id, { css, js: source });
                cssFileId = undefined;
              } else {
                // Generate a unique CSS filename - handle .css.ts files correctly
                const parsedPath = path.parse(id);
                const baseName = parsedPath.name.replace(/\.css$/, ''); // Remove .css if present
                cssFileName = `${baseName}.css`;

                // Emit the CSS as an asset
                cssFileId = this.emitFile({
                  type: 'asset',
                  fileName: cssFileName,
                  source: css,
                });

                // Store the compilation result in cache
                buildCache.set(id, { css, js: source, cssFileId });
              }
            }

            // Use the transformed JS from the compiler (source now contains the processed exports)
            // Return JavaScript based on inline mode
            let jsCode: string;

            if (inlineCss) {
              // Inline CSS mode - inject CSS into HTML head
              jsCode = `${source}

// Auto-generated by vite-plugin-surimi (build mode - inline)
// Inject CSS directly into the page
const css = ${JSON.stringify(css)};
const styleId = 'surimi-style-' + ${JSON.stringify(id.replace(/[^a-zA-Z0-9]/g, '_'))};

// Remove existing style if it exists
const existingStyle = document.getElementById(styleId);
if (existingStyle) {
  existingStyle.remove();
}

// Create and inject new style element
const styleElement = document.createElement('style');
styleElement.id = styleId;
styleElement.textContent = css;
document.head.appendChild(styleElement);
`;
            } else {
              // Asset mode - import CSS file
              jsCode = `${source}

// Auto-generated by vite-plugin-surimi (build mode - assets)
// Import the generated CSS file - Vite will handle injection
import "./${cssFileName}";
`;
            }

            return jsCode;
          } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            this.error(`Failed to compile Surimi file ${id}: ${message}`);
          }
        }

        return null;
      },
      generateBundle() {
        // Ensure all CSS files are properly emitted
        console.log('Generated CSS files:', Array.from(buildCache.keys()));

        // Log information about emitted CSS assets
        for (const [filePath, { cssFileId }] of buildCache) {
          if (cssFileId) {
            const fileName = this.getFileName(cssFileId);
            console.log(`CSS asset emitted: ${fileName} for ${filePath}`);
          } else {
            console.log(`CSS inlined for: ${filePath}`);
          }
        }
      },
    },
  ];
}
